ren() {
if [[ $* =~ ^: ]]
then
s=$*;s=${s:1}
[[ $s =~ ' :' ]] ||{ echo Put in the other ':' as marker for regex replacement pattern;return; }
a=${s% :*};a=${a%% }
b=${s#* :}
# converting PCRE to GNU-extended regex
x=`echo $a |sed -r 's/\[.*?\\\[wds][^]]*\]/./ig; s/\\\d/[0-9]/g'`
echo GNU-ext regex:  $x
if [[ ${a##'('} =~ ^/ ]]
then
	# s is the first longest literal
	s=`echo $x |sed -r 's/([^[|*+\\{.]+).*/\1/'`
	d=${s%/*}
	d=${d//'('/};d=${d//')'/}
else
	d=~+
fi
# The RHS of Bash value below on Linux-port Windows (Msys2), use \r\n while Linux-port on Mac use \r, instead of \n
IFS=$'\r\n'
for l in `find $d -noleaf -regextype posix-extended -iregex ".*?$x" | gre -oie "${a/'/'/'\/'}"`
{
mv -vbS _old $l `echo $l | sed -r "s~$x~$b~i"`
}
elif test $1 ;then mv -vbS _old $*
fi
}
